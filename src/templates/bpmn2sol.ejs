<% callActivities.forEach( nodeId => { %>
    import "<%= nodeName(nodeId) %>";
    <% }); -%>
    <% if(oracleTaskMap.size > 0) { -%>
    contract Oracle_Wrapper {
    <% oracleTaskMap.forEach((oracleKey, nodeId, map) => { -%>
        function <%= getOracleFunction(nodeId) %> (<%= typeParameters(nodeId, true, false) %>, function (uint<%= typeParameters(nodeId, false, true) %>) external returns (bool)) external returns (uint);
    <% }) -%>
    }  
    <% } -%>
    
    
    <% var allChildren = getAllChildren(processId(), false); 
       var allEvents = allEventTypes();
       var contracts2Call = getContracts2Call(); -%>
    
    contract <%= nodeName(processId()) %>_Contract {
        uint tokens = <%= subprocessStartMarking(processId()) %>;
        address owner = 0;
        address parent = 0;
        uint subprocesses = 0;
        uint [] requestedID;
    <% if(contracts2Call.length > 0) { -%>
        address[] subprocesses_array;
    <% contracts2Call.forEach( nodeId => { -%>
        uint <%= nodeName(nodeId) %>_activeInstances = 0;
    <% });} -%>
    <% /* --------- Solidity events to throw when an end message event is thrown  ---------------------------- */ -%>
    <% var messages = getThrowingMessages();
       if(messages.length > 0) { 
        messages.forEach(nodeId => { -%>
        event <%= nodeName(nodeId) %>_Mesage(bytes32 messageText); 
    <% })} -%>
        event Element_Execution_Completed(uint elementId);
    <% /* --------- Fields for interacting with the worklist in case of external tasks  --------------- */ -%>
        <%= nodeName(processId()) %>_WorkList workList = new <%= nodeName(processId()) %>_WorkList();
    <%  nodeList.forEach(nodeId => {
        var node = nodeMap.get(nodeId);
          if((is(node, 'bpmn:Task') && !is(node, 'bpmn:ServiceTask') && !is(node, 'ScriptTask')) || (catchingMessages.indexOf(nodeId) >= 0 && isStartingContractEvent(nodeId, processId()))) { -%>
        uint active_<%= nodeName(nodeId) %> = 0;
    <%  }}) -%>
    <% /* --------- Fields for interacting with external resources by means of callbacks (Oracle)  --------------- */ -%>
    <% if(oracleInfo.size > 0) { -%>
        mapping(uint => address) oracleAddresses;
    <%    oracleTaskMap.forEach((oracleKey, nodeId, map) => { -%>
        uint active_<%= nodeName(nodeId) %> = 0;    
    <% })} -%>
        <%- globalDeclarations() -%>
    
        function <%= nodeName(processId()) %>_Contract() {
            owner = msg.sender;
    <% oracleTaskMap.forEach((oracleKey, nodeId, map) => { -%>
            oracleAddresses[<%= flowNodeIndex(nodeId) %>] = <%= oracleInfo.get(oracleKey).address %>;
    <% }) -%>
            for (uint i = 0; i < <%= getCountExternalTasks() %>; i++)
                requestedID.push(0);
            step(tokens);
        }
    
        function setParent(address newParent) {
            if (owner == msg.sender)
                parent = newParent;
        }
    
    <% /* ----------- Global Handlers: for catching events from external subprocesses  ------------------------------- */ -%>
        function handleGlobalDefaultEnd() {
    <% if(contracts2Call.length > 0 ) { -%>
            address childAddress = msg.sender;
            for (uint i = 0; i < subprocesses_array.length; i++)
                if (subprocesses_array[i] == childAddress) {
                    uint index = uint(1) << i;
    <% contracts2Call.forEach(function (nodeId) {
           var node = nodeMap.get(nodeId); -%>
                    if (<%= nodeName(nodeId) %>_activeInstances & index != 0) {
                        <%= nodeName(nodeId) %>_activeInstances &= uint(~index);
                        if (<%= nodeName(nodeId) %>_activeInstances == 0) {
                            subprocesses &= uint(~<%= flowNodeIndex(nodeId) %>);
                            subprocesses_array[i] = 0;
    <% if(!is(node, 'bpmn:BoundaryEvent') && !node.triggeredByEvent) { -%>
                            tokens |= uint(<%= postMarking(nodeId) %>);
                            step(tokens);
    <% } -%>
                        }
    <% if (node.loopCharacteristics && node.loopCharacteristics.$type === 'bpmn:MultiInstanceLoopCharacteristics' && node.loopCharacteristics.isSequential) { -%>
                        else {
                            subprocesses_array[i + 1] = new <%= nodeName(nodeId) %>_Contract();
                            <%= nodeName(nodeId) %>_Contract(subprocesses_array[subprocesses_array.length - 1]).setParent(<%= nodeName(processId()) %>_Contract(this));
                        }
    <% } -%>
                        Element_Execution_Completed(<%= flowNodeIndex(nodeId) %>);
                        return;
                    }
    <% }) -%>
                }
    <% } else { -%>
            // ................ Nothing to do ...........
    <% } -%>
        }
    
    <% if (contracts2Call.length > 0 || getThrowingEvents(processId(), 'Signal').length > 0) { -%>
        function handleGlobalSignalEnd(bytes32 eventName) {
            if (parent != 0)
                <%= nodeName(processId()) %>_Contract(parent).handleGlobalSignalEnd(eventName);
    <% if (allEvents.indexOf('Signal') >= 0) { -%>
            else
                broadcastSignal_<%= nodeName(processId()) %>();
    <% } -%>
        }
    <% }
       ['Error', 'Escalation'].forEach((evType) => { -%>
        function handleGlobal<%= evType %>End(bytes32 eventName) {
    <%  if (contracts2Call.length > 0 && allEvents.indexOf(evType) >= 0) { -%>
            address childAddress = msg.sender;
            for (uint i = 0; i < subprocesses_array.length; i++)
                if (subprocesses_array[i] == childAddress) {
    <% contracts2Call.forEach(function (nodeId) { -%>
                    if (<%= nodeName(nodeId) %>_activeInstances & uint(1) << i != 0) {
                        <%= nodeName(nodeId) %>_Handle<%= evType%>EndEvent(eventName);
                        return;
                    }
    <% }) -%>
                }
    <% } -%>
            if (parent != 0)
                <%= nodeName(processId()) %>_Contract(parent).handleGlobal<%= evType%>End(eventName);
    <% if (evType === 'Error') { -%>
            else
                tokens &= uint(~kill_<%= nodeName(processId()) %>());
    <% } -%>
         }
    
    <% }) -%>
    <% /* -------------------- Local Handlers, for catching events from embedded subprocesses -------------------- */ -%>
    <% allChildren.forEach(function (subprocId) {
           allEvents.forEach(function (evType) { -%>
        function <%= nodeName(subprocId) %>_Handle<%= evType%>EndEvent(bytes32 eventName) {
    <% if (evType !== 'Signal') {
                  var catchingEvents = getCatchingEvents(subprocId, evType);            
                  catchingEvents.forEach ( function (eventId) { -%>
            if (eventName == '<%= nodeName(eventId) %>') {
    <%                if (isInterrupting(eventId)) { -%>
                step(tokens & uint(~kill_<%= nodeName(getParent(eventId)) %>()) | uint(<%= postMarking(eventId) %>));
    <%                } else {
                            var auxId =  getContractName(eventId); -%>
                <%= nodeName(auxId) %>_activeInstances |= uint(1) << subprocesses_array.length;
                subprocesses_array.push(new <%= nodeName(auxId) %>_Contract());
                <%= nodeName(auxId) %>_Contract(subprocesses_array[subprocesses_array.length - 1]).setParent(<%= nodeName(processId()) %>_Contract(this));
    <%                } -%>
                return;
            }
    <%            }) } -%>
    <%          if (subprocId === processId()) { -%>
            if (parent != 0) {
                <%= nodeName(processId()) %>_Contract(parent).handleGlobal<%= evType%>End(eventName); 
                return;
            }     
    <%          if (evType === 'Error') { -%>
            tokens &= uint(~kill_<%= nodeName(processId()) %>());
    <%            } else if (evType === 'Signal') { -%>
            broadcastSignal_<%= nodeName(processId()) %>();
    <%            }  
                } else {  -%>
            <%= nodeName(nodeMap.get(subprocId).$parent.id) %>_Handle<%= evType%>EndEvent(eventName);
     <%        } -%>
        }
    
    <%  }) -%>
    <% }) -%>
    <% /* --------------------------------- Kill Childrens & Broadcast ------------------------------ */ -%>
    <% allChildren.forEach(function (nodeId) { -%>
        function kill_<%= nodeName(nodeId) %>() returns (uint) {
            uint tokensToKill = 0;
    <% if(nodeId !== processId() && (multiinstanceActivities.indexOf(nodeId) >= 0 || callActivities.indexOf(nodeId) >= 0 || nonInterruptingEvents.indexOf(nodeId) >= 0)) { -%>
           for(uint i = 0; i < subprocesses_array.length; i++) 
                if(<%= nodeName(nodeId) %>_activeInstances & uint(1) << i != 0) {
                    <%= nodeName(nodeId) %>_Contract(subprocesses_array[i]).kill_<%= nodeName(nodeId) %>();
                    subprocesses_array[i] = 0;
                }
            <%= nodeName(nodeId) %>_activeInstances = 0;
            subprocesses &= uint(~<%= flowNodeIndex(nodeId) %>);
            <% catchingMessages.forEach(childId => {
             if((isStartingContractEvent(childId, processId()) && nodeMap.get(childId).$parent.id === nodeId) || (nodeMap.get(childId).attachedToRef && nodeMap.get(childId).attachedToRef.id === nodeId)) { -%>
            active_<%= nodeName(childId) %> = 0;
    <%  }}) -%>
    <% } else {                                                                                        /* if node is embeded kill all the elements on it */ -%>
            tokensToKill |= uint(<%= subprocessMarking(nodeId) %>);
    <%     nodeList.forEach(childId => {
             var node = nodeMap.get(childId);
             if((node.$parent.id === nodeId && is(node, 'bpmn:Task') && !is(node, 'bpmn:ServiceTask') && !is(node, 'ScriptTask')) 
                  || (catchingMessages.indexOf(childId) >= 0 && (isStartingContractEvent(childId, processId()) || (nodeMap.get(childId).attachedToRef && nodeMap.get(childId).attachedToRef.id === nodeId)))) { -%>
            active_<%= nodeName(childId) %> = 0;
    <%  }}) -%>
    <% }
            var directChildren = getAllChildren(nodeId, true);                                           /* Propagate propagate and kill to all the embeded compound nodes*/
            directChildren.forEach(function (childId) { -%>
            tokensToKill |= kill_<%= nodeName(childId) %>();
    <% }) 
       if (nodeId === processId()) { -%>
            tokens &= uint(~tokensToKill);
            return 0;   
    <% } else { -%>
            return tokensToKill;
    <% } -%>
        }
    
     <% if (allEvents.indexOf('Signal') >= 0 || contracts2Call.length > 0 ) { -%>
        function broadcastSignal_<%= nodeName(nodeId) %>() {
    <% if(nodeId !== processId() && (multiinstanceActivities.indexOf(nodeId) >= 0 || callActivities.indexOf(nodeId) >= 0 || nonInterruptingEvents.indexOf(nodeId) >= 0)) { /* if the node determines a contract, propagate signal to all active instances */ -%>
            for(uint i = 0; i < subprocesses_array.length; i++)
                if(<%= nodeName(nodeId) %>_activeInstances & uint(1) << i != 0) 
                    <%= nodeName(nodeId) %>_Contract(subprocesses_array[i]).broadcastSignal_<%= nodeName(nodeId) %>();
    <% }
           var directChildren = getAllChildren(nodeId, true);                                           /* Propagate the signal to all embeded compound node in the current contract */
           directChildren.forEach(function (childId) { -%>
            broadcastSignal_<%= nodeName(childId) %>();
    <% })
        var boundaryList = getCatchingEvents(nodeId, 'Signal');                                              /* Catching all the signals in the current node */
        boundaryList.forEach ( function (eventId) {
          var evt = nodeMap.get(eventId);
          if (is(evt, 'bpmn:IntermediateCatchEvent')) {
              if (isPartOfDeferredChoice(eventId)) { -%>
            if (tokens & <%= deferredChoiceMarking(eventId) %> == <%= deferredChoiceMarking(eventId) %>)
                step(tokens & uint(~<%= deferredChoiceMarking(eventId) %>) | <%= postMarking(eventId) %>);
    <%        } else { -%>
            if (tokens & <%= preMarking(eventId) %> == <%= preMarking(eventId) %>)
                step(tokens & uint(~<%= preMarking(eventId) %>) | <%= postMarking(eventId) %>);
    <% }  } else if(is(evt, 'bpmn:StartEvent') && !nodeMap.get(evt.$parent.id).triggeredByEvent) { -%>
           // Pending ...
    <%    } else if (isInterrupting(eventId)) { -%>
            step(tokens & uint(~kill_<%= nodeName(getParent(eventId)) %>()) | <%= postMarking(eventId) %>);
    <%    } else {
               var auxId = getContractName(eventId); -%>
            <%= nodeName(auxId) %>_activeInstances |= uint(1) << subprocesses_array.length;
            subprocesses_array.push(new <%= nodeName(auxId) %>_Contract());
            <%= nodeName(auxId) %>_Contract(subprocesses_array[subprocesses_array.length - 1]).setParent(<%= nodeName(processId()) %>_Contract(this));
    <%     }})  -%>
        }
    
    <% } else { -%>
        function broadcastSignal_<%= nodeName(nodeId) %>() {
            // Nothing to do ...
        }
    
    <% }}) -%>
    <% /* --------------------------------- Catching Messages Events ------------------------------- */ -%>
    <% var messageEvents = getMessages();
           messageEvents.forEach(evt => {
               var parent = nodeMap.get(evt.$parent.id);
               if(parent.triggeredByEvent) { -%>
        function <%= nodeName(evt.id) %>() internal returns (bool) {
    <%  if (isInterrupting(evt.id)) { -%>
            tokens = tokens & uint(~kill_<%= nodeName(parent.$parent.id) %>()) | <%= subprocessStartMarking(parent.id) %>;
    <%   } else { -%>
            <%= nodeName(parent.id) %>_activeInstances |= uint(1) << subprocesses_array.length;
            subprocesses_array.push(new <%= nodeName(parent.id) %>_Contract());
            <%= nodeName(parent.id) %>_Contract(subprocesses_array[subprocesses_array.length - 1]).setParent(<%= nodeName(processId()) %>_Contract(this));
            subprocesses |= <%= flowNodeIndex(parent.id) %>;
    <%   } -%>
            return true;
        }
    
    <%        } else {
        var attachedTo = evt.attachedToRef.id; -%>
        function <%= nodeName(evt.id) %>() internal returns (bool) {
    <% if (isInterrupting(evt.id)) { -%>
            step (tokens & uint(~kill_<%= nodeName(attachedTo) %>()) | <%= postMarking(evt.id) %>);
    <%     } else { -%>
            <%= nodeName(evt.id) %>_activeInstances |= uint(1) << subprocesses_array.length;
            subprocesses_array.push(new <%= nodeName(evt.id) %>_Contract());
            <%= nodeName(evt.id) %>_Contract(subprocesses_array[subprocesses_array.length - 1]).setParent(<%= nodeName(processId()) %>_Contract(this));
    <%     } -%>
            return true;
        }
    
    <%  }}) -%>
    <% /* --------------------------------- Functions from BPMN elements -------------------------- */ -%>
    <%  boundaryMessages = getMessages();
        nodeList.forEach( nodeId => {
            let node = nodeMap.get(nodeId),
                nodePreMarking = preMarking(nodeId),
                nodePostMarking = postMarking(nodeId);
    if (node.loopCharacteristics && node.loopCharacteristics.$type === 'bpmn:MultiInstanceLoopCharacteristics') {
        if (!is (node, "bpmn:Task")) { -%>
        function <%= nodeName(nodeId) %>() internal {
            subprocesses |= <%= flowNodeIndex(nodeId) %>;
    <% /* Replace the value size for the real loop size of the multi-instance*/  -%>
            uint size = 2;
            for(uint i = 0; i < size; i++) {  
                <%= nodeName(nodeId) %>_activeInstances |= uint(1) << subprocesses_array.length;
    <% if (node.loopCharacteristics.isSequential) { -%>
                subprocesses_array.push(0);    
    <% } else { -%>
                subprocesses_array.push(new <%= nodeName(nodeId) %>_Contract());
                <%= nodeName(nodeId) %>_Contract(subprocesses_array[subprocesses_array.length - 1]).setParent(<%= nodeName(processId()) %>_Contract(this));
    <% } -%>
              }
    <% if (node.loopCharacteristics.isSequential) { -%>
            subprocesses_array[subprocesses_array.length - size] = new <%= nodeName(nodeId) %>_Contract();
            <%= nodeName(nodeId) %>_Contract(subprocesses_array[subprocesses_array.length - size]).setParent(<%= nodeName(processId()) %>_Contract(this));  
    <% } -%>
          }
    
     <% } else { -%>
        function <%= nodeName(nodeId) %>() internal {
             uint index = subprocesses_array.length;
             subprocesses_array.push(new <%= nodeName(nodeId) %>_Contract());
             subprocesses_array.push(new <%= nodeName(nodeId) %>_Contract());
             <%= nodeName(nodeId) %>_activeInstances |= (uint(1) << index) + (uint(1) << index + 1);
        }
    
    <% } } else if (callActivities.indexOf(nodeId) >= 0) { -%>
        function <%= nodeName(nodeId) %>() internal {
            uint index = subprocesses_array.length;
            <%= nodeName(nodeId) %>_Contract child = new <%= nodeName(nodeId) %>_Contract();
            child.setParent(<%= nodeName(nodeId) %>_Contract(this));
            subprocesses_array.push(child);
            subprocesses |= <%= flowNodeIndex(nodeId) %>;
            <%= nodeName(nodeId) %>_activeInstances |= uint(1) << index;
        }
    
    <% } else if (is(node, 'bpmn:EndEvent')) {
           var evtType = eventType(nodeId); -%>
        function <%= nodeName(nodeId) %>(uint localTokens) internal returns (uint) {
            tokens = localTokens & uint(~<%= nodePreMarking %>);
    <% if (evtType !== 'Default') {
           if (evtType === 'Terminate') { -%>
            tokens = tokens & uint(~kill_<%= nodeName(node.$parent.id) %>());
    <%     } else if (evtType !== 'Message') { 
                if (node.$parent.id === processId() || is(nodeMap.get(processId()), 'bpmn:BoundaryEvent')) { -%>
            if (parent != 0)
                <%= nodeName(processId()) %>_Contract(parent).handleGlobal<%= evtType %>End('<%= nodeName(nodeId) %>');
    <% if (!is(nodeMap.get(processId()), 'bpmn:BoundaryEvent')) {
                if(evtType === 'Error') { -%>
            else
                tokens &= uint(~kill_<%= nodeName(node.$parent.id) %>());
    <%             } else if (evtType === 'Signal') { -%>
            else
                broadcastSignal_<%= nodeName(node.$parent.id) %>();
    <%             }  -%>
    <%      }    } else { -%>
            <%= nodeName(node.$parent.id) %>_Handle<%= evtType %>EndEvent('<%= nodeName(nodeId) %>');
    <%      }   }
        } 
        if (evtType === 'Default' || evtType === 'Message' || evtType === 'Terminate') {
            if (evtType !== 'Terminate') { -%>
            if (tokens & <%= subprocessMarking(node.$parent.id) %> != 0) {
    <% if(evtType === 'Message') { -%>
                <%= nodeName(nodeId) %>_Mesage('<%= nodeName(nodeId) %>');
    <% } -%>
                return tokens;
            }
    <% } if(node.$parent.id === processId() || is(nodeMap.get(processId()), 'bpmn:BoundaryEvent')) { -%>
            if (parent != 0)
                <%= nodeName(processId()) %>_Contract(parent).handleGlobalDefaultEnd();
    <% } else { -%>
            <%= nodeName(node.$parent.id) %>_HandleDefaultEndEvent();
    <% }           } -%>
            Element_Execution_Completed(<%= flowNodeIndex(nodeId) %>);
    <% if(evtType === 'Message') { -%>
            <%= nodeName(nodeId) %>_Mesage('<%= nodeName(nodeId) %>');
    <% } -%>
            return tokens;
        }
    
    <% } else if (is(node, 'bpmn:IntermediateThrowEvent')) { -%>
        function <%= nodeName(nodeId) %>(uint localTokens) internal returns (uint) {
    <%  var evtType = eventType(nodeId);
        if (evtType !== 'Default') {
        if (node.$parent.id === processId()) {
           if(evtType !== 'Message') { -%>
            if (parent != 0)
                <%= nodeName(processId()) %>_Contract(parent).handleGlobal<%= evtType %>End('<%= nodeName(nodeId) %>');
    <%         if (evtType === 'Signal') { -%>
            else
                broadcastSignal_<%= nodeName(node.$parent.id) %>();
    <%         }  -%>
    <% }} else if(evtType !== 'Message') { -%>
            <%= nodeName(node.$parent.id) %>_Handle<%= evtType %>EndEvent('<%= nodeName(nodeId) %>');
    <%  } if(evtType === 'Message') { -%>
            <%= nodeName(nodeId) %>_Mesage('<%= nodeName(nodeId) %>');
    <% }} -%>
           Element_Execution_Completed(<%= flowNodeIndex(nodeId) %>); 
    <%     if (isPartOfDeferredChoice(nodeId)) { -%>
            return localTokens & uint(~<%= deferredChoiceMarking(nodeId) %>) | <%= postMarking(nodeId) %>;
    <%     } else { -%>
            return localTokens & uint(~<%= nodePreMarking %>) | <%= nodePostMarking %>;
    <%     } -%>
        }
    
    <% } else if ((is(node, 'bpmn:BoundaryEvent') || is(node, 'bpmn:StartEvent')) && eventType(nodeId) !== 'Message') { -%>
    <% } else if (is(node, 'bpmn:SubProcess')) {
              if (isEmbeddedSubprocess(nodeId)) { -%>
        function <%= nodeName(nodeId) %>_HandleDefaultEndEvent() {
            uint localTokens = tokens;
            if (localTokens & <%= subprocessMarking(nodeId) %> == 0 <%- extendedSubprocessMarking(nodeId, false) %>) {
                subprocesses &= uint(~<%= flowNodeIndex(nodeId) %>);
    <% catchingMessages.forEach(childId => {
             if((isStartingContractEvent(childId, processId()) && nodeMap.get(childId).$parent.id === nodeId) || (nodeMap.get(childId).attachedToRef && nodeMap.get(childId).attachedToRef.id === nodeId)) { -%>
            active_<%= nodeName(childId) %> = 0;
            localTokens &= uint(~kill_<%= nodeName(childId) %>());
    <%  }}) -%>
                
                step(localTokens | uint(<%= nodePostMarking %>));
            }
        }
    
    <% }} else if (is(node, 'bpmn:ExclusiveGateway') && node.outgoing && node.outgoing.length > 1) { -%>
        function <%= nodeName(nodeId) %>(uint localTokens) internal returns (uint) {
    <% var i = 0; node.outgoing.forEach(function (outgoing) { -%>
            <%= i > 0 ? 'else ' : '' %><%if (i < node.outgoing.length - 1){ %>if (<%- getCondition(outgoing) %>)<% } -%>
                return localTokens & uint(~<%= nodePreMarking %>) | <%= flowEdgeIndex(outgoing.id) %>;
    <% i++;}) -%>
        }
    
    <% } else if (is(node, 'bpmn:ScriptTask')) { -%>
        function <%= nodeName(nodeId) %>(uint localTokens) internal returns (uint) {
    <% if (node.script) { -%>
            <%- nodeFunctionBody(nodeId) -%>
    <% } -%>
            Element_Execution_Completed(<%= flowNodeIndex(nodeId) %>);
            return localTokens & uint(~<%= nodePreMarking %>) | <%= nodePostMarking %>;
        }
    
    <% } else if (is(node, 'bpmn:ServiceTask')) { -%>
        function <%= nodeName(node.id) %>_start (uint localTokens) internal returns (uint) {
    <%  var functName = oracleTaskMap.get(nodeId); 
        var localInfo = oracleInfo.get(functName); -%>        
            uint reqId = Oracle_Wrapper(oracleAddresses[<%= flowNodeIndex(nodeId) %>]).<%= localInfo.functionName %> (<%= concatParameters(node.id, true, false, false) %>, this.<%= nodeName(node.id) %>_callbak);
            requestedID[<%= nodeRealIndex(node.id) %>] |= uint(1) << reqId;
            return localTokens & uint(~<%= nodePreMarking %>);
        }
    
        function <%= nodeName(node.id) %>_callbak (uint reqId<%= concatParameters(node.id, false, true, true) %>) external returns (bool) {
            uint localTokens = tokens;
            if (msg.sender != oracleAddresses[<%= flowNodeIndex(node.id) %>]) 
                return false ;
            uint index = uint(1) << reqId;
            if(requestedID[<%= nodeRealIndex(node.id) %>] & index == index) {
                <%= nodeFunctionBody(nodeId) %>
                requestedID[<%= nodeRealIndex(node.id) %>] &= ~uint(index);
                step (localTokens | <%= nodePostMarking %>);
                Element_Execution_Completed(<%= flowNodeIndex(nodeId) %>);
                return true;
            }
            return false ;
        }
    
    <% } else if(is(node, 'bpmn:Task') || is(node, 'bpmn:ReceiveTask' ) || (catchingMessages.indexOf(nodeId) >= 0 && isStartingContractEvent(nodeId, processId()) || is(node, 'bpmn:IntermediateCatchEvent'))) { -%>
    
        function <%= nodeName(node.id) %>_start (uint localTokens) internal returns (uint) {
            uint reqId = workList.<%= nodeParameters(node.id) ? nodeName(node.id) : 'DefaultTask' %>_start (this.<%= nodeName(node.id) %>_callback);
            active_<%= nodeName(nodeId) %> |= uint(1) << reqId;
    <% if (isPartOfDeferredChoice(nodeId)) { -%>
            return localTokens;
    <% } else { -%>
            return localTokens & uint(~<%= nodePreMarking %>);
    <% } -%>
        }
    
        function <%= nodeName(nodeId) %>_callback (uint reqId<%= concatParameters(node.id, true, true, true) %>) returns (bool) {
            if (active_<%= nodeName(nodeId) %> == 0) 
                return false;
            uint index = uint(1) << reqId;
            if(active_<%= nodeName(nodeId) %> & index == index) {
                active_<%= nodeName(nodeId) %> &= ~index;
    <% if(boundaryMessages.indexOf(node) >= 0) { -%>
                <%= nodeName(node.id) -%>();
                step(tokens);
    <% } else if (isPartOfDeferredChoice(node.id)) { -%>
                <%- nodeFunctionBody(nodeId) %>
    <% var activeTasks = getDeferredChoiceElements(nodeId);
       activeTasks.forEach(elemId => { -%>
                active_<%= nodeName(elemId) %> = 0;
    <%  })    -%>
                step(tokens & uint(~<%= deferredChoiceMarking(nodeId) %>) | <%= nodePostMarking %>);
    <% } else { -%>
                <%- nodeFunctionBody(nodeId) %>
                step (tokens | <%= nodePostMarking %>);
    <% } -%>
                Element_Execution_Completed(<%= flowNodeIndex(nodeId) %>);
                return true;
            }
            return false ;
        }
    
    <% }}); -%>
    <% /* ----------------- Step: Method to execute internal activities automatically ------------------ */ -%>
        function step(uint localTokens) internal { 
            bool done = false;
            while (!done) {
    <% nodeList.forEach( nodeId => {
        if(catchingMessages.indexOf(nodeId) < 0) {
            var node = nodeMap.get(nodeId);
            var nodePreMarking = preMarking(nodeId);
            var nodePostMarking = postMarking(nodeId);
            if (is(node, 'bpmn:ExclusiveGateway')) { -%>
                if (localTokens & <%= nodePreMarking %> != 0) {
    <%          if (node.outgoing && node.outgoing.length > 1) { -%>
                    localTokens = <%= nodeName(nodeId) %>(localTokens); 
    <%          } else { -%>
                    localTokens = localTokens & uint(~<%= nodePreMarking %>) | <%= postMarking(nodeId) %>; 
    <%          } -%>
                    continue;
                }
    <% } else if(is(node, 'bpmn:SubProcess') && !node.triggeredByEvent && multiinstanceActivities.indexOf(nodeId) < 0) { -%>
                if (localTokens & <%= nodePreMarking %> == <%= nodePreMarking %>) {
                    subprocesses |= <%= flowNodeIndex(nodeId) %>;
                    localTokens = localTokens & uint(~<%= nodePreMarking %>) | <%= subprocessStartMarking(nodeId) %>;
                    continue;
                }
    <% } else if(is(node, 'bpmn:ParallelGateway') || is(node,'bpmn:EventBasedGateway')) { -%>
                if (localTokens & <%= nodePreMarking %> == <%= nodePreMarking %>) {      
                    localTokens = localTokens & uint(~<%= nodePreMarking %>) | <%= nodePostMarking %>;
                    continue;
                }
    <% } else if(is(node, 'bpmn:ReceiveTask')) {
        if (isPartOfDeferredChoice(nodeId)) { -%>
                if (active_<%= nodeName(nodeId) %> == 0 && localTokens & <%= deferredChoiceMarking(nodeId) %> == <%= deferredChoiceMarking(nodeId) %>) {
                    localTokens = <%= nodeName(nodeId) %>_start(localTokens);
                    continue;
                }
    <%  } else { -%>
                if (localTokens & <%= nodePreMarking %> == <%= nodePreMarking %>) {
                    localTokens = <%= nodeName(nodeId) %>_start(localTokens);
                    continue;
                }
    <% }} else if((is(node, 'bpmn:Task') && !is(node, 'bpmn:ScriptTask'))) { -%>
                if (localTokens & <%= nodePreMarking %> == <%= nodePreMarking %>) {
                    localTokens = <%= nodeName(nodeId) %>_start(localTokens);
                    continue;
                }
    <% } else if(is(node, 'bpmn:ScriptTask') || is(node, 'bpmn:EndEvent') || is(node, 'bpmn:IntermediateThrowEvent')) {
             if (isPartOfDeferredChoice(nodeId)) { -%>
                if (active_<%= nodeName(nodeId) %> == 0 && localTokens & <%= deferredChoiceMarking(nodeId) %> == <%= deferredChoiceMarking(nodeId) %>) {
                    localTokens = <%= nodeName(nodeId) %>(localTokens);
                    continue;
                }
    <%  } else { -%>
                if (localTokens & <%= nodePreMarking %> == <%= nodePreMarking %>) {
                    localTokens = <%= nodeName(nodeId) %>(localTokens); 
                    continue;
                }
    <%}} else if (callActivities.indexOf(nodeId) >= 0 || multiinstanceActivities.indexOf(nodeId) >= 0) { -%>
                if (localTokens & <%= nodePreMarking %> == <%= nodePreMarking %>) {
                    <%= nodeName(nodeId) %>();
                    localTokens = localTokens & uint(~<%= nodePreMarking %>);
                    continue;
                }
    <% }}}); -%>
    <% var messageEvents = catchingMessages;
           messageEvents.forEach(evtId => {
               if(isStartingContractEvent(evtId, processId())) {
               var evt = nodeMap.get(evtId);
               var parent = nodeMap.get(evt.$parent.id);
               if(parent.triggeredByEvent) {
                   if (isInterrupting(evtId)) { -%>
                if (active_<%= nodeName(evtId) %> == 0 && (localTokens & <%= subprocessMarking(parent.$parent.id) %> & uint(~(<%= subprocessMarking(parent.id) %>)) != 0 || getStartedFlowNodes() & <%= subprocessNodeMarking(processId()) %> != 0 || subprocesses != 0)) {
                    localTokens = <%= nodeName(evt.id) %>_start(localTokens);
                    continue;
                }
    <%              } else { -%>
                if (active_<%= nodeName(evtId) %> == 0 && (localTokens & <%= subprocessMarking(parent.$parent.id) %> != 0 || getStartedFlowNodes() & <%= subprocessNodeMarking(processId()) %> != 0 || subprocesses & uint(~<%= flowNodeIndex(parent.id) %>) != 0)) {
                    localTokens = <%= nodeName(evt.id) %>_start(localTokens);
                    continue;
                }
    <% }       } else if (isBoundaryEvent(evt.id)) {
        var attachedTo = evt.attachedToRef.id; -%>
    <% if (multiinstanceActivities.indexOf(attachedTo) >= 0 || callActivities.indexOf(attachedTo) >= 0) { -%>
                if (<%= nodeName(attachedTo) %>_activeInstances != 0) {
                    localTokens = <%= nodeName(evt.id) %>_start(localTokens);
                    continue;
                }
    <% } else { -%>
                if (active_<%= nodeName(evt.id) %> == 0 && (tokens & <%= subprocessMarking(attachedTo) %> != 0 || getStartedFlowNodes() & <%= subprocessNodeMarking(attachedTo) %> != 0)) {
                    localTokens = <%= nodeName(evt.id) %>_start(localTokens);
                    continue;
                }
     <% }   } else if(isPartOfDeferredChoice(evtId)) { %>
                if (active_<%= nodeName(evtId) %> == 0 && localTokens & <%= deferredChoiceMarking(evtId) %> == <%= deferredChoiceMarking(evtId) %>) {
                    localTokens = <%= nodeName(evt.id) %>_start(localTokens);
                    continue;
                }
    <%       } else { -%>
                if (localTokens & <%= preMarking(evtId) %> != 0) {
                    localTokens = <%= nodeName(evt.id) %>_start(localTokens);
                    continue;
                }
    <% }} else {
             if(isPartOfDeferredChoice(evtId)) { %>
                if (active_<%= nodeName(evtId) %> == 0 && localTokens & <%= deferredChoiceMarking(evtId) %> == <%= deferredChoiceMarking(evtId) %>) {
                    localTokens = localTokens & uint(~<%= deferredChoiceMarking(evtId) %>) | <%= postMarking(evtId) %>;
                    continue;
                }
    <%      } else { -%>
                if (localTokens & <%= preMarking(evtId) %> != 0) {
                    localTokens = localTokens & uint(~<%= preMarking(evtId) %>) | <%= postMarking(evtId) %>;
                    continue;
                }
    <% }}}) -%>
                done = true;
            }
            tokens = localTokens;
        }
     
        function getRunningFlowNodes() returns (uint) {
            uint flowNodes = 0;
            uint localTokens = tokens;
    <% nodeList.forEach( nodeId => {
        let node = nodeMap.get(nodeId),
        nodePreMarking = preMarking(nodeId);
        if(is(node, 'bpmn:ServiceTask')) { -%>
            if(requestedID[<%= nodeRealIndex(node.id) %>] != 0)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <%  } else if (is(node, 'bpmn:ScriptTask')) { -%>
            if(localTokens & <%= nodePreMarking %> == <%= nodePreMarking %>)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <%  } }); -%>
            return flowNodes;
        }
    
    <% /* ----------------- Method to obtain masks of enabled tasks ------------------ */ -%>
        function getStartedFlowNodes() returns (uint) {
            uint flowNodes = 0;
            uint localTokens = tokens;
    <% nodeList.forEach( nodeId => {
        let node = nodeMap.get(nodeId),
        nodePreMarking = preMarking(nodeId);
        if(catchingMessages.indexOf(nodeId) >= 0) {
            if(isStartingContractEvent(nodeId, processId())) { -%>
            if(active_<%= nodeName(nodeId) %> != 0)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <% } } else if(is(node, "bpmn:SubProcess") && node.triggeredByEvent) { -%>
    <%  } else if(is(node, "bpmn:BoundaryEvent") || is(node, "bpmn:StartEvent")) {
            if(nonInterruptingEvents.indexOf(nodeId) < 0 && eventType(nodeId) === 'Message') {
                if(is(node, "bpmn:BoundaryEvent")) {
                if (multiinstanceActivities.indexOf(node.attachedToRef.id) >= 0 || callActivities.indexOf(node.attachedToRef.id) >= 0 ) { -%>
                if (subprocesses & <%= flowNodeIndex(node.attachedToRef.id) %> == <%= flowNodeIndex(node.attachedToRef.id) %>) 
    <%              } else { -%>
            if (localTokens & <%= subprocessMarking(node.attachedToRef.id) %> != 0 <%= extendedSubprocessMarking(node.$parent.id, true) %>)
    <%      }   -%>
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <%      } else {
                  var parentId = getParent(nodeId); 
                  if(nodeMap.get(parentId).triggeredByEvent) { -%>
            if (localTokens & <%= subprocessMarking(parentId) %> & uint(~<%= subprocessMarking(node.$parent.id) %>) != 0)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <%            } else { -%>
            if(active_<%= nodeName(nodeId) %> != 0)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <% } }}} else if (!(is(node, 'bpmn:ExclusiveGateway') || is(node, 'bpmn:ParallelGateway') || is(node, 'bpmn:EventBasedGateway') 
                      || is(node, 'bpmn:StartEvent') && node.$parent && is(node.$parent, 'bpmn:SubProcess') ||
                      multiinstanceActivities.indexOf(nodeId) >= 0 || is(node, 'bpmn:CallActivity'))) {
           if(is(node, 'bpmn:ServiceTask') || is(node, 'ScriptTask')) { -%>
            if(localTokens & <%= nodePreMarking %> == <%= nodePreMarking %>)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <%     } else if(is(node, 'bpmn:Task')) { -%>
            if(active_<%= nodeName(nodeId) %> != 0)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <%    }         -%>
    <% }}); -%>
    <% callActivities.forEach( nodeId => { -%>
            if (subprocesses & <%= flowNodeIndex(nodeId) %> == <%= flowNodeIndex(nodeId) %>)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <% }); %>
    <% multiinstanceActivities.forEach( nodeId => { -%>
            if (<%= nodeName(nodeId) %>_activeInstances != 0)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <% }); -%>
    <% nonInterruptingEvents.forEach (nodeId => {
        var node = nodeMap.get(nodeId);
        var localId = is(node, "bpmn:StartEvent") ? node.$parent.id : nodeId; -%>
            if (<%= nodeName(localId) %>_activeInstances != 0)
                flowNodes |= <%= flowNodeIndex(nodeId) %>;
    <% }) -%>
            return flowNodes;
        }
    
        function getWorkListAddress() returns (address) {
            return workList;
        }
    
        function getTaskRequestIndex(uint taskId) returns (uint) { 
    <% nodeList.forEach( nodeId => {
        var node = nodeMap.get(nodeId);
        if(is(node, 'bpmn:Task') && !is(node, 'bpmn:ServiceTask') && !is(node, 'ScriptTask') || (catchingMessages.indexOf(nodeId) >= 0 && isStartingContractEvent(nodeId, processId()))) { -%>
            if (taskId == <%= flowNodeIndex(nodeId) %>)
                return active_<%= nodeName(nodeId) %>;
    <%  }}) -%>
        }
    
    <% /* ------------- Methods to obtain information about multiple contract instances running ------------------ */ -%>
    <% if (callActivities.length > 0 || multiinstanceActivities.length > 0 || nonInterruptingEvents.length > 0) { -%>
        function getSubprocessAddresses() returns (address []) {
            return subprocesses_array;
        }
    
        function getInstances(uint instanceNode) returns (uint) {
    <% callActivities.forEach( nodeId => { -%>
            if (instanceNode & <%= flowNodeIndex(nodeId) %> != 0)
                return <%= nodeName(nodeId) %>_activeInstances;
    <% }); -%>
    <% multiinstanceActivities.forEach( nodeId => { -%>
            if (instanceNode & <%= flowNodeIndex(nodeId) %> != 0)
                return <%= nodeName(nodeId) %>_activeInstances;
    <% }); -%>
    <% nonInterruptingEvents.forEach( nodeId => { 
            var node = nodeMap.get(nodeId);
            var localId = is(node, "bpmn:StartEvent") ? node.$parent.id : nodeId; -%>
            if (instanceNode & <%= flowNodeIndex(nodeId) %> != 0)
                return <%= nodeName(localId) %>_activeInstances;
    <% }); -%>
            return 0;
        }
    
    <% } if(multiinstanceActivities.length > 0) { -%>
        function handleMultiInstanceEnd() {
            address child = msg.sender;
            uint value;
    <% multiinstanceActivities.forEach( nodeId => { -%>
            value = 1;
            for (uint i = 0; i < subprocesses_array.length; i++) {
                if (subprocesses_array[i] == child) {
                    <%= nodeName(nodeId) %>_activeInstances &= uint(~ uint(1) << i);
                    if (<%= nodeName(nodeId) %>_activeInstances == 0)
                        tokens |= <%= postMarking(nodeId) %>;
                    return;
                }
                value *= 2;
            }
    <% }); %>
        }
    <% } -%>
    }
    
    <% if (multiinstanceActivities.length > 0) multiinstanceActivities.forEach( nodeId => {
        if (is(nodeMap.get(nodeId), "bpmn:Task")) { -%>
    contract <%= nodeName(nodeId) %>_Contract {
        address public parent = 0;
        function <%= nodeName(nodeId) %>_Contract() {
            parent = msg.sender;
        }
        function <%= nodeName(nodeId) %>() returns (bool) {
            if (parent == 0)
                return false; // Should we return a boolean?
            <%= nodeName(processId()) %>_Contract(parent).handleMultiInstanceEnd();
            return true;
        }
    }
    <% } }); -%>